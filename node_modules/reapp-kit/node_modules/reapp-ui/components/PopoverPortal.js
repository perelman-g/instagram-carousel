'use strict';

var _objectWithoutProperties = function (obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var React = require('react');
var Animate = require('react-animate-state');
var Component = require('../component');
var Tappable = require('../helpers/Tappable');
var clone = require('../lib/niceClone');

module.exports = Component({
  name: 'PopoverPortal',

  mixins: [Animate],

  getInitialState: function getInitialState() {
    return {
      step: 0,
      index: 1
    };
  },

  componentDidMount: function componentDidMount() {
    var popover = this.refs.popover.getDOMNode();
    var position = this.getPositionState(popover, this.props.target);
    this.setState(position);

    // animate open
    this.animate({ step: 1 }, this.props.animationDuration);
  },

  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    var nextState = {};

    if (nextProps.left && nextProps.top) nextState = Object.assign(nextState, {
      popoverLeft: nextProps.left,
      popoverTop: nextProps.top
    });

    if (nextProps.open) nextState = Object.assign(nextState, { open: nextProps.open });

    this.setState(nextState);
  },

  getPositionState: function getPositionState(popover, target) {
    var targetRect = target.getBoundingClientRect();
    var tops = this.getTop(popover, targetRect);
    var lefts = this.getLeft(popover, targetRect);
    return Object.assign({}, tops, lefts);
  },

  ensureEdgePadding: function ensureEdgePadding(pos, max, width) {
    return Math.min(
    // upper limit
    max - this.props.edgePadding - width,
    // lower limit
    Math.max(this.props.edgePadding, pos));
  },

  getLeft: function getLeft(popover, targetRect) {
    var targetCenter = targetRect.left + targetRect.width / 2;
    var popoverHalfWidth = popover.clientWidth / 2;
    var popoverLeft = targetCenter - popoverHalfWidth;

    popoverLeft = this.ensureEdgePadding(popoverLeft, window.innerWidth, popover.clientWidth);

    var arrowLeft = 0;
    var arrowCenter = window.innerWidth - popoverHalfWidth;

    // adjust arrow when close to edge
    if (targetCenter < popoverHalfWidth) arrowLeft = -popoverHalfWidth - targetCenter;else if (targetCenter > arrowCenter) arrowLeft = targetCenter - arrowCenter;

    arrowLeft = this.ensureEdgePadding(arrowLeft, window.innerWidth, this.props.arrowSize / 2 + 10);

    return { arrowLeft: arrowLeft, popoverLeft: popoverLeft };
  },

  getTop: function getTop(popover, targetRect) {
    var targetTop = targetRect.top - window.scrollY;
    var targetCenter = targetRect.top + targetRect.height / 2;
    var windowHalfWidth = window.innerHeight / 2;
    var arrowOnBottom = targetCenter > windowHalfWidth;
    var top = arrowOnBottom ? targetTop - popover.clientHeight - this.props.arrowSize : targetTop + targetRect.height + this.props.arrowSize;

    var arrowTop = arrowOnBottom ? popover.clientHeight : -this.props.arrowSize;

    // since its rotated 45deg, the real height is less 1/4 of set height
    var arrowHeight = this.props.arrowSize - this.props.arrowSize / 4;
    var arrowInnerTop = arrowHeight * (arrowOnBottom ? -1 : 1);
    var popoverTop = this.ensureEdgePadding(top, window.innerHeight, popover.clientHeight);

    return { arrowInnerTop: arrowInnerTop, arrowTop: arrowTop, popoverTop: popoverTop };
  },

  handlePopoverSelect: function handlePopoverSelect(cb) {
    if (!this.state.isClosing) {
      this.setState({ isClosing: true });
      this.close(cb);
    }
  },

  close: function close(cb) {
    this.afterClose(cb);
    // todo: this broke with portals
    // this.tweenState('step', {
    //   endValue: 2,
    //   duration: this.props.animationDuration,
    //   onEnd: this.afterClose.bind(this, cb)
    // });
  },

  afterClose: function afterClose(cb) {
    var _this = this;

    setTimeout(function () {
      if (_this.props.onClose) {
        if (cb && typeof cb === 'function') cb();

        _this.props.onClose();
      }
    });
  },

  addPositionStyles: function addPositionStyles() {
    this.addStyles('popover', {
      top: this.state.popoverTop,
      left: this.state.popoverLeft
    });

    this.addStyles('arrow', {
      top: this.state.arrowTop,
      width: this.props.arrowSize,
      height: this.props.arrowSize,
      marginLeft: -(this.props.arrowSize / 2) + this.state.arrowLeft
    });

    this.addStyles('arrowInner', {
      top: this.state.arrowInnerTop,
      width: this.props.arrowSize,
      height: this.props.arrowSize
    });
  },

  render: function render() {
    var _this2 = this;

    var _props = this.props;
    var children = _props.children;
    var open = _props.open;

    var props = _objectWithoutProperties(_props, ['children', 'open']);

    if (open) {
      this.addClass('open');
      this.addStyles('open');
    }

    this.addPositionStyles();

    var linkStyles = this.getStyles('link');

    return React.createElement(
      'div',
      _extends({}, this.componentProps(), props),
      React.createElement(Tappable, _extends({}, this.componentProps('bg'), {
        onTap: this.handlePopoverSelect,
        stopPropagation: true
      })),
      React.createElement(
        'div',
        this.componentProps('popover'),
        React.createElement(
          'div',
          this.componentProps('arrow'),
          React.createElement('div', this.componentProps('arrowInner'))
        ),
        React.createElement(
          'div',
          this.componentProps('list'),
          React.Children.map(children, function (li, i) {
            return React.createElement(
              'div',
              { key: i, styles: _this2.getStyles('item', i) },
              React.createElement(
                Tappable,
                {
                  onTap: _this2.handlePopoverSelect.bind(_this2, li.props.onClick) },
                clone(li, { styles: linkStyles }, true)
              )
            );
          })
        )
      )
    );
  }
});
'use strict';

var _objectWithoutProperties = function (obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var React = require('react');
var Component = require('../component');
var GalleryCard = require('./GalleryCard');
var TouchableArea = require('../helpers/TouchableArea');
var Animate = require('react-animate-state');
var Icon = require('./Icon');
var Button = require('./Button');

var _require = require('reapp-scroller');

var Scroller = _require.Scroller;

module.exports = Component({
  name: 'Gallery',

  mixins: [Animate],

  propTypes: {
    images: React.PropTypes.array.isRequired,
    width: React.PropTypes.number,
    height: React.PropTypes.number,
    onClose: React.PropTypes.func,
    animationDuration: React.PropTypes.number,
    animations: React.PropTypes.object
  },

  getDefaultProps: function getDefaultProps() {
    return {
      width: window.innerWidth,
      height: window.innerHeight,
      animationDuration: 200,
      animations: {
        self: 'fade'
      }
    };
  },

  getInitialState: function getInitialState() {
    return {
      left: 0,
      step: 0,
      index: 1
    };
  },

  componentWillMount: function componentWillMount() {
    this.scroller = new Scroller(this.handleScroll, {
      snapping: true
    });
  },

  componentDidMount: function componentDidMount() {
    if (this.props.animations) this.animate({ step: 1 }, this.props.animationDuration);

    this.scroller.setDimensions(this.props.width, this.props.height, this.props.width * this.props.images.length, this.props.height);
    this.scroller.setSnapSize(this.props.width, this.props.height);
  },

  handleScroll: function handleScroll(left, top, zoom) {
    if (this.isMounted()) this.setState({ left: left });
  },

  handleClose: function handleClose() {
    var _this = this;

    if (this.props.animations && !this._isClosing) {
      this._isClosing = true;
      this.animate({ step: 2 }, this.props.animationDuration, function () {
        setTimeout(_this.props.onClose);
      });
    } else {
      this.props.onClose();
    }
  },

  render: function render() {
    var _this2 = this;

    var _props = this.props;
    var width = _props.width;
    var height = _props.height;
    var images = _props.images;
    var onClose = _props.onClose;
    var closeIconProps = _props.closeIconProps;

    var props = _objectWithoutProperties(_props, ['width', 'height', 'images', 'onClose', 'closeIconProps']);

    var close = onClose && React.createElement(
      Button,
      _extends({ chromeless: true, onTap: this.handleClose }, this.componentProps('close')),
      React.createElement(Icon, _extends({
        color: '#fff',
        file: require('../assets/icons/x.svg'),
        size: 20,
        stroke: 2
      }, closeIconProps))
    );

    var images = images.map(function (url, i) {
      if (_this2.state.left < (i - 1) * width || _this2.state.left > (i + 1) * width) return null;

      // Find highest resolution image
      return React.createElement(GalleryCard, {
        left: _this2.state.left,
        key: i,
        index: i,
        url: url,
        width: width,
        height: height
      });
    });

    this.addStyles({
      width: width,
      height: height
    });

    return React.createElement(
      'div',
      _extends({}, props, this.componentProps()),
      close,
      React.createElement(
        TouchableArea,
        { scroller: this.scroller },
        images
      )
    );
  }
});
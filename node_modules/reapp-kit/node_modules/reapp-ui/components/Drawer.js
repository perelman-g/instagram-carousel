'use strict';

var _objectWithoutProperties = function (obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; };

var _defineProperty = function (obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: key == null || typeof Symbol == 'undefined' || key.constructor !== Symbol, configurable: true, writable: true }); };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var React = require('react');

var _require = require('reapp-scroller');

var Scroller = _require.Scroller;

var Component = require('../component');
var TouchableArea = require('../helpers/TouchableArea');
var AnimatableContainer = require('../helpers/AnimatableContainer');
var StaticContainer = require('../helpers/StaticContainer');
var DrawerBehavior = require('../behaviors/DrawerBehavior');

module.exports = Component({
  name: 'Drawer',

  propTypes: {
    behavior: React.PropTypes.object,
    translate: React.PropTypes.object,
    from: React.PropTypes.oneOf(['left', 'right', 'top', 'bottom']),
    touchableProps: React.PropTypes.object,
    onClose: React.PropTypes.func,
    open: React.PropTypes.bool,
    dragger: React.PropTypes.bool,
    draggerWidth: React.PropTypes.number,
    width: React.PropTypes.number,
    height: React.PropTypes.number
  },

  getDefaultProps: function getDefaultProps() {
    return {
      behavior: DrawerBehavior,
      from: 'left',
      open: true,
      dragger: true,
      width: window.innerWidth,
      height: window.innerHeight
    };
  },

  getInitialState: function getInitialState() {
    return {
      offset: 0,
      externalScroller: !!this.props.scroller
    };
  },

  componentWillMount: function componentWillMount() {
    if (this.state.externalScroller) {
      return;
    }this.scroller = new Scroller(this.handleScroll, {
      scrollingX: this.isSideDrawer(),
      scrollingY: !this.isSideDrawer(),
      snapping: true
    });
  },

  componentDidMount: function componentDidMount() {
    this.measureScroller();
    window.addEventListener('resize', this.measureScroller);

    this.ignoreScroll = false;

    this.scrollClosed(false);

    if (this.props.open) this.scrollOpen(true);
  },

  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    if (nextProps.open !== this.props.open) {
      if (nextProps.open) this.scrollOpen(true);else this.scrollClosed(true);
    }
  },

  componentWillUnmount: function componentWillUnmount() {
    window.removeEventListener('resize', this.measureScroller);
  },

  measureScroller: function measureScroller() {
    if (this.state.externalScroller) {
      return;
    }var width = this.props.width;
    var totalWidth = this.props.width;
    var height = this.props.height;
    var totalHeight = this.props.height;

    if (this.isSideDrawer()) totalWidth = width * 2;else totalHeight = height * 2;

    this.scroller.setDimensions(width, height, totalWidth, totalHeight);
    this.scroller.setSnapSize(width, height);

    if (this.props.from === 'bottom') this.scroller.scrollTo(0, totalHeight, false);
  },

  scrollClosed: function scrollClosed(animated) {
    this.scrollTo(100, animated);
  },

  scrollOpen: function scrollOpen(animated) {
    this.scrollTo(0, animated);
  },

  // handles scrolling to a percent
  scrollTo: function scrollTo(percent, animated) {
    if (!this.scroller) {
      return;
    }var dec = percent * 0.01;

    if (this.isSideDrawer()) this.scroller.scrollTo(dec * this.props.width, 0, animated);else this.scroller.scrollTo(0, dec * this.props.height, animated);
  },

  isSideDrawer: function isSideDrawer() {
    var _this = this;

    return ['left', 'right'].filter(function (x) {
      return x === _this.props.from;
    }).length;
  },

  isClosed: function isClosed() {
    return this.isSideDrawer() ? this.state.offset === this.props.width : this.state.offset === this.props.height;
  },

  ignoreScroll: true,

  handleScroll: function handleScroll(left, top) {
    if (this.ignoreScroll) {
      return;
    }var offset, transform;

    switch (this.props.from) {
      case 'left':case 'right':
        offset = left;
        break;
      case 'top':case 'bottom':
        offset = top;
        break;
    }

    this.setState({ offset: offset });

    // onClose callback
    if (this.isClosed() && this.props.onClose) {
      this.props.onClose();
    }
  },

  draggerSide: {
    left: 'right',
    right: 'left',
    top: 'bottom',
    bottom: 'top'
  },

  render: function render() {
    var _props = this.props;
    var from = _props.from;
    var open = _props.open;
    var behavior = _props.behavior;
    var translate = _props.translate;
    var touchableProps = _props.touchableProps;
    var children = _props.children;
    var scroller = _props.scroller;
    var dragger = _props.dragger;
    var draggerWidth = _props.draggerWidth;

    var props = _objectWithoutProperties(_props, ['from', 'open', 'behavior', 'translate', 'touchableProps', 'children', 'scroller', 'dragger', 'draggerWidth']);

    var animatedProps = Object.assign({}, {
      translate: translate || behavior[from].translate(this.state.offset)
    }, this.props.animatedProps);

    if (open) {
      this.addClass('open', this.props.open);
      this.addStyles({ zIndex: 5 }); // move above other drawers
    }

    this.addStyles('from-' + this.props.from);

    if (dragger) {
      this.addStyles('dragger', '' + this.props.from + 'Dragger');
      this.addStyles('dragger', _defineProperty({}, this.draggerSide[from], this.isClosed() ? -this.getConstant('edgeWidth') : 0));

      if (draggerWidth) this.addStyles('dragger', { width: draggerWidth });
    }

    var updateChildren = this.state.offset === 0;

    if (this.props.update === false) updateChildren = false;

    if (touchableProps && touchableProps.styles) this.addStyles('dragger', touchableProps.styles);

    return React.createElement(
      AnimatableContainer,
      _extends({}, this.componentProps(), animatedProps, props),
      React.createElement(
        'div',
        this.componentProps('inner'),
        dragger && React.createElement(TouchableArea, _extends({}, touchableProps, this.componentProps('dragger'), {
          scroller: scroller || this.scroller,
          currentTargetOnly: true,
          allowDefault: true
        })),
        React.createElement(
          StaticContainer,
          { update: updateChildren },
          children
        )
      )
    );
  }
});
'use strict';

var _normalize$normalizeAll = require('../lib/normalizeStyles');

// Styled - helps with this.context.theme.styles

// It tracks four types of styles:
//   1. styles: runtime loaded styles
//   2. addedStyles: imperative styles added in component
//   3. propStyles: styles passed in with props
//   4. conditionalStyles: firstChild, lastChild

module.exports = {
  componentWillUpdate: function componentWillUpdate(nextProps) {
    this.setupStyles(nextProps);
  },

  componentWillMount: function componentWillMount() {
    this.setupStyles(this.props);

    if (this.context.theme && this.context.theme.styles) this.styles = this.context.theme.styles[this.name] || {};
  },

  setupStyles: function setupStyles(props) {
    this.addedStyles = {};

    if (props.styles) {
      var pStyles;

      // normalize styles
      if (Array.isArray(props.styles)) pStyles = props.styles.map(_normalize$normalizeAll.normalize);else pStyles = _normalize$normalizeAll.normalizeAll(props.styles);

      this.propStyles = pStyles;
      this.propAddedStyles = {};
      delete props.styles;
    }
  },

  getPropStyles: function getPropStyles(ref) {
    return ref === 'self' && Array.isArray(this.propStyles) ? this.propStyles : this.propStyles && this.propStyles[ref];
  },

  getPropAddedStyles: function getPropAddedStyles(ref) {
    return this.propAddedStyles && this.propAddedStyles[ref];
  },

  addStyleTo: function addStyleTo(obj, key, style) {
    obj[key] = (obj[key] || []).concat(style);
  },

  getStyles: function getStyles(ref, index) {
    if (!this.styles) {
      return;
    }ref = ref || 'self';

    return ((this.styles[ref] && Array.isArray(this.styles[ref]) ? this.styles[ref] : [this.styles[ref]]) || []).concat(this.addedStyles[ref] || []).concat(this.getConditionalStyles(ref, index)).concat(this.getPropStyles(ref) || []).concat(this.getPropAddedStyles(ref) || []);
  },

  keys: {
    firstChild: 'firstChild',
    lastChild: 'lastChild'
  },

  // styles for things like 'firstChild', 'lastItem'
  // todo: mediaStyles
  getConditionalStyles: function getConditionalStyles(ref, index) {
    var conditionalStyles = [];

    if (this.props.index === 0 || index === 0) {
      var key = ref === 'self' ? this.keys.firstChild : '' + ref + 'FirstChild';

      if (this.styles[key]) conditionalStyles = this.styles[key];
    }

    if (this.props.total && this.props.index === this.props.total - 1) {
      var key = ref === 'self' ? this.keys.lastChild : '' + ref + 'LastChild';

      if (this.styles[key]) conditionalStyles.push(this.styles[key]);
    }

    return conditionalStyles;
  },

  // supports adding an object directly (ie this.styles.somestyle)
  // or a string or an array of strings
  addStyles: function addStyles(ref, styles) {
    if (Array.isArray(styles)) styles.forEach(this._addStyle.bind(this, ref));else this._addStyle(ref, styles);
  },

  // adds styles onto a ref
  _addStyle: function _addStyle(ref, styles) {
    // if given just an object or string, add as the styles object for 'self'
    if (!styles && (typeof ref === 'object' || typeof ref === 'string')) {
      styles = ref;
      ref = 'self';
    }

    // allows using string to lookup styles
    if (typeof styles === 'string') {
      var propStyles = this.getPropStyles(styles);

      if (propStyles) this.propAddedStyles[ref] = propStyles;

      styles = this.getStyles(styles);
    }

    // return if no styles found
    if (!styles) {
      return;
    } // merge onto our addedStyles object
    this.mergeStyles(this.addedStyles, ref, styles);
  },

  // merge styles onto obj for ref
  // needs to be reasonably performant (thus the verbosity)
  mergeStyles: function mergeStyles(obj, ref, styles) {
    var curStyles = obj[ref];

    // if we have styles already on the object
    if (curStyles && curStyles.length) {
      if (Array.isArray(styles)) obj[ref] = curStyles.concat(styles);else obj[ref][curStyles.length] = styles;
    } else {
      if (Array.isArray(styles)) obj[ref] = styles;else obj[ref] = [styles];
    }
  },

  // handles checking for shorthand styling, for use with components
  // that pass down style properties to their children dynamically
  mergeStylesProps: function mergeStylesProps() {
    var _this = this;

    for (var _len = arguments.length, stylesProps = Array(_len), _key = 0; _key < _len; _key++) {
      stylesProps[_key] = arguments[_key];
    }

    var result = {};

    stylesProps.forEach(function (prop) {
      if (!prop) return;

      // convert shorthand to proper
      if (Array.isArray(prop)) prop = { self: prop };

      Object.keys(prop).forEach(function (key) {
        _this.mergeStyles(result, key, prop[key]);
      });
    });

    return result;
  },

  // get a style value
  getStyleVal: function getStyleVal(ref, prop) {
    // if no ref given, we just use "self"
    if (typeof prop === 'undefined') {
      prop = ref;
      ref = 'self';
    }

    var styles = this.getStyles(ref);
    return this._findDominantVal(styles, prop);
  },

  // get another components styles
  getStylesForComponent: function getStylesForComponent(componentName, ref) {
    ref = ref || 'self';

    return getStyles(componentName).map(function (styles) {
      return styles[ref];
    }).filter(function (x) {
      return typeof x !== 'undefined';
    });
  },

  // get another components style value
  getStyleValForComponent: function getStyleValForComponent(componentName, ref, prop) {
    if (!prop) {
      prop = ref;
      ref = 'self';
    }

    return this._findDominantVal(this.getStylesForComponent(componentName, ref), prop);
  },

  _findDominantVal: function _findDominantVal(styles, prop) {
    if (!styles) {
      return null;
    }var stylesForProp = styles.map(function (style) {
      return style[prop];
    }).filter(function (x) {
      return typeof x !== 'undefined';
    });

    return stylesForProp[stylesForProp.length - 1];
  }
};
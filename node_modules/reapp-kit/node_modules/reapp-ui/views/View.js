'use strict';

var _objectWithoutProperties = function (obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var React = require('react');
var Component = require('../component');
var TitleBar = require('../components/TitleBar');
var StaticContainer = require('../helpers/StaticContainer');
var ScrollTopable = require('../mixins/ScrollTopable');
var AnimatedScrollToTop = require('../mixins/AnimatedScrollToTop');
var Animator = require('../lib/Animator');
var ScrollState = require('../mixins/ScrollState');

module.exports = Component({
  name: 'View',

  mixins: [ScrollState, ScrollTopable('static'), AnimatedScrollToTop, Animator('viewList', ['index'])],

  propTypes: {
    title: React.PropTypes.node,
    titleLeft: React.PropTypes.node,
    titleRight: React.PropTypes.node,

    index: React.PropTypes.number,

    // add animations in view list
    isInViewList: React.PropTypes.bool,

    animations: React.PropTypes.object,

    // pass inner div props (scrollable content)
    innerProps: React.PropTypes.object,

    // pass titlebar props
    titleBarProps: React.PropTypes.object,

    // pass overlay div props
    overlayProps: React.PropTypes.object,

    // place a node outside the inner pane
    after: React.PropTypes.node,

    // disable pointer events
    inactive: React.PropTypes.bool,

    // make the StaticContainer inside fullscreen
    fullscreen: React.PropTypes.bool,

    // see scrollTopable
    scrollTop: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.number]),

    // don't add extra visuals like shadow/overlay
    plain: React.PropTypes.bool
  },

  getInitialState: function getInitialState() {
    return {
      isScrolling: false
    };
  },

  animationSource: 'viewList',

  componentWillMount: function componentWillMount() {
    // set animationContext
    this.animationContext = {
      index: this.props.index
    };
  },

  componentDidMount: function componentDidMount() {
    this.scrollListener(this.refs.inner.getDOMNode());

    if (this.props.onComponentMounted) this.props.onComponentMounted(this.props.index);
  },

  handleDoubleTap: function handleDoubleTap() {
    if (this.refs.inner) this.animatedScrollToTop(this.refs.inner.getDOMNode(), 300, this.getScrollTop());
  },

  hasOverlay: function hasOverlay() {
    return this.props.animations && this.props.animations.overlay;
  },

  render: function render() {
    var _props = this.props;
    var animations = _props.animations;
    var children = _props.children;
    var title = _props.title;
    var titleLeft = _props.titleLeft;
    var titleRight = _props.titleRight;
    var index = _props.index;
    var width = _props.width;
    var height = _props.height;
    var innerProps = _props.innerProps;
    var titleBarProps = _props.titleBarProps;
    var overlayProps = _props.overlayProps;
    var viewList = _props.viewList;
    var inactive = _props.inactive;
    var fullscreen = _props.fullscreen;
    var after = _props.after;
    var plain = _props.plain;
    var isInViewList = _props.isInViewList;

    var props = _objectWithoutProperties(_props, ['animations', 'children', 'title', 'titleLeft', 'titleRight', 'index', 'width', 'height', 'innerProps', 'titleBarProps', 'overlayProps', 'viewList', 'inactive', 'fullscreen', 'after', 'plain', 'isInViewList']);

    // titlebar props modifications
    var modifiedTitleBarProps = Object.assign({
      onDoubleTap: this.handleDoubleTap,
      isInViewList: isInViewList
    }, titleBarProps);

    var shouldUpdate = !animations || !inactive;

    if (this.state.isScrolling) this.addClass('inner', 'isScrolling');

    if (inactive) this.addStyles('inactive');

    if (plain) this.addStyles('static', 'plain');

    if (this.hasOverlay()) this.addStyles('overlay', {
      display: inactive ? 'block' : 'none',
      top: this.props.titleBarHeight || this.getConstant('titleBarHeight')
    });

    return React.createElement(
      'div',
      _extends({}, this.componentProps(), props),
      title && React.createElement(
        TitleBar,
        _extends({
          left: titleLeft,
          right: titleRight
        }, modifiedTitleBarProps),
        title
      ),
      React.createElement(
        'div',
        _extends({}, this.componentProps('inner'), innerProps),
        React.createElement(
          StaticContainer,
          _extends({}, this.componentProps('static'), {
            fullscreen: fullscreen,
            update: shouldUpdate }),
          React.createElement(
            'div',
            null,
            children
          )
        ),
        !plain && React.createElement('div', this.componentProps('shadow'))
      ),
      after && React.createElement(
        StaticContainer,
        { update: shouldUpdate },
        after
      ),
      !plain && this.hasOverlay() && React.createElement('div', _extends({}, this.componentProps('overlay'), overlayProps))
    );
  }
});
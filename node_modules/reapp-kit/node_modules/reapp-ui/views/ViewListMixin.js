'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var React = require('react/addons');

var _require = require('reapp-scroller');

var Scroller = _require.Scroller;

var Component = require('../component');
var TitleBar = require('../components/TitleBar');
var TouchableArea = require('../helpers/TouchableArea');
var Animator = require('../lib/Animator');
var clone = require('../lib/niceClone');

// ViewLists are the most complex piece of the UI kit.
// Their usage is simple, but they manage a lot of state,
// encompass many animations, and also need to know about multiple
// child components (see TitleBar, View, Button, Icon)

module.exports = Object.assign(Animator('viewList', ['width', 'height']), {
  propTypes: {
    scrollToStep: React.PropTypes.number,
    disableScroll: React.PropTypes.bool,
    width: React.PropTypes.number,
    height: React.PropTypes.number,
    onTouchStart: React.PropTypes.func,
    onTouchEnd: React.PropTypes.func,
    onViewEntering: React.PropTypes.func,
    onViewEntered: React.PropTypes.func,
    onViewLeaving: React.PropTypes.func,
    onViewLeft: React.PropTypes.func,
    onStep: React.PropTypes.func,
    scrollerProps: React.PropTypes.object
  },

  getViewListInitialState: function getViewListInitialState() {
    return {
      // We put children in state, so when a parent removes a view
      // we can animate backwards, and then remove them from state
      children: this.props.children,
      width: this.props.width,
      height: this.props.height,
      step: this.props.scrollToStep || 0
    };
  },

  componentWillMount: function componentWillMount() {
    this.setupBeforeMount(this.props);
  },

  componentDidMount: function componentDidMount() {
    this.setScrollPosition();
    this.setupAfterMount(this.props);
  },

  setupBeforeMount: function setupBeforeMount(props, cb) {
    delete this.scroller;
    this.scroller = new Scroller(this.handleScroll, props.scrollerProps);
    this.setupViewList(props, cb);
  },

  setupAfterMount: function setupAfterMount(props) {
    this.setupDimensions(props);
    this.setTouchableAreaProps(props);
    this.runViewCallbacks(this.state.step);
    window.addEventListener('resize', this.resize);
    this.didMount = true;
  },

  componentWillUnmount: function componentWillUnmount() {
    window.removeEventListener('resize', this.resize);
  },

  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    var _this = this;

    // if changing type of viewlist
    if (nextProps.name !== this.props.name) {
      var step = this.state.step; //this.props.scrollToStep;
      delete this.scroller;
      return this.setupBeforeMount(nextProps, function () {
        _this.setupAfterMount(nextProps);
        _this.setTouchableAreaProps(nextProps);
        _this.handleScrollToStep(step, nextProps);
      });
    }

    this.setTouchableAreaProps(nextProps);

    if (this.props.disableScroll !== nextProps.disableScroll) {
      if (nextProps.disableScroll) {
        return this.disableAnimation();
      } else this.enableAnimation();
    }

    if (this._isAnimating || !this.didMount) {
      return;
    } // new scrollToStep
    this.handleScrollToStep(this.props.scrollToStep, nextProps);
  },

  // animates forward and backward depending
  handleScrollToStep: function handleScrollToStep(step, nextProps) {
    var _this2 = this;

    if (nextProps.scrollToStep === step) {
      return this.setupViewList(nextProps);
    } // if advancing
    if (nextProps.scrollToStep >= this.state.step) {
      this.setupViewList(nextProps, function () {
        _this2.scrollToStep(nextProps.scrollToStep);
      });
    } else this.scrollToStep(nextProps.scrollToStep, function () {
      _this2.setupViewList(nextProps);
    });
  },

  // todo: this shouldn't need to do so much here
  // for now this fixes a bug where if you start with a step > 0
  setScrollPosition: function setScrollPosition() {
    var step = this.state.step;
    var isVertical = this.props.vertical;
    var left = !isVertical ? step * this.state.width : 0;
    var top = isVertical ? step * this.state.height : 0;

    this.scroller.setPosition(left, top);
    this.scroller.scrollTo(left, top, false);
  },

  animationContext: function animationContext() {
    return {
      height: this.state.height,
      width: this.state.width
    };
  },

  // allow custom title bar heights
  getTitleBarHeight: function getTitleBarHeight() {
    return this.props.titlebarProps && typeof this.props.titlebarProps.height === 'number' ? this.props.titleBarProps.height : this.getConstant('titleBarHeight');
  },

  setupViewList: function setupViewList(props, cb) {
    var width = props.width;
    var height = props.height;
    var children = props.children;

    this.setupViewEnterStates(children);

    if (!children || !children.length) {
      // bugfix so if we start with no children but add later it works
      this.scroller.setDimensions(width, height, width, height);
      return;
    }

    children = children.filter(function (child) {
      return !!child;
    });

    var isVertical = this.props.vertical;
    var fullWidth = isVertical ? width : width * children.length;
    var fullHeight = isVertical ? height * children.length : height;

    this.scroller.setDimensions(width, height, fullWidth, fullHeight);

    if (this.isMounted()) this.setState({ children: children });

    // for animating forwards
    if (cb) {
      // if no child is there, we want to wait for it to mount
      if (!this.state.children[props.scrollToStep]) {
        this._advancingToIndex = props.scrollToStep;
        this._afterViewMounted = cb;
      } else cb();
    }
  },

  // used by scrollToStep to ensure we animate after mount
  handleViewMounted: function handleViewMounted() {
    if (this._afterViewMounted) this._afterViewMounted();

    delete this._advancingToIndex;
    delete this._afterViewMounted;
  },

  // scrolls the viewList to a given step
  scrollToStep: function scrollToStep(step, cb) {
    var _this3 = this;

    if (step !== this.state.step) {
      this._isAnimating = true;

      var isVertical = !!this.props.vertical;

      this.scroller.scrollTo(!isVertical ? this.state.width * step : 0, isVertical ? this.state.height * step : 0, true);

      this.onViewEntered = function () {
        _this3.onViewEntered = null;
        _this3._isAnimating = false;
        if (typeof cb === 'function') cb();
      };
    }
  },

  setupDimensions: function setupDimensions(props) {
    if (props.resizeWithWindow) this.setState({
      width: window.innerWidth,
      height: window.innerHeight
    });
  },

  resize: function resize() {
    this.setupDimensions(this.props);
    this.setScrollPosition();
  },

  setupViewEnterStates: function setupViewEnterStates(children) {
    if (!children || !children.length) this.visibleViews = [];else {
      this.visibleViews = new Array(children.length - 1);
      this.visibleViews[0] = true;
    }
  },

  // this is a hack, but the Scroller lib fires a scroll event that
  // results in not respecting the props.scrollToStep on mount
  // .... we need to improve the Scroller lib
  ignoreNextScrollEvent: true,

  // Called back from Scroller on each frame of scroll
  handleScroll: function handleScroll(left, top) {
    if (!this.props.disableScroll) {
      if (this.ignoreNextScrollEvent) this.ignoreNextScrollEvent = false;else {
        var step;

        if (this.props.vertical) step = top / this.state.height;else step = left / this.state.width;

        if (step !== this.prevStep) {
          if (step % 1 === 0) {
            this.stepper.setSync(step);
            this.setState({ step: step });
          }

          this.stepper.setSync(step);

          this.runViewCallbacks(step);

          if (this.props.onStep) this.props.onStep(step);

          this.prevStep = step;
        }
      }
    }
  },

  runViewCallbacks: function runViewCallbacks(step) {
    if (step % 1 === 0) {
      this._hasCalledEnteringLeaving = false;

      this.callProperty('onViewEntered', step);

      var prev = step - 1;
      var next = step + 1;

      if (this.visibleViews[prev]) {
        this.callProperty('onViewLeft', prev);
        this.visibleViews[prev] = false;
      } else if (this.visibleViews[next]) {
        this.callProperty('onViewLeft', next);
        this.visibleViews[next] = false;
      }
    } else if (!this._hasCalledEnteringLeaving) {
      var entering, leaving;
      var floor = Math.floor(step);
      var ceil = Math.ceil(step);

      // if sliding forwards
      if (this.visibleViews[floor]) {
        entering = ceil;
        leaving = floor;
      } else {
        entering = floor;
        leaving = ceil;
      }

      this.visibleViews[entering] = true;
      this.callProperty('onViewEntering', entering);
      this.callProperty('onViewLeaving', leaving);
      this._hasCalledEnteringLeaving = true;
    }
  },

  callProperty: function callProperty(name) {
    var _this4 = this;

    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    setTimeout(function () {
      // apply to viewlist first
      if (_this4[name]) _this4[name].apply(_this4, args);

      // then call any external
      if (_this4.props[name]) _this4.props[name].apply(_this4, args);
    });
  },

  isOnStage: function isOnStage(index) {
    return index >= this.state.step - 1 && index <= this.state.step + 1;
  },

  getTitleBarProps: function getTitleBarProps() {
    return Object.assign({
      transparent: !this.props.noFakeTitleBar,
      animationSource: 'viewList'
    }, this.props.titleBarProps);
  },

  getViewAnimations: function getViewAnimations(view) {
    return view && !view.props.animations ? this.props.viewAnimations : view.props.animations;
  },

  setTouchableAreaProps: function setTouchableAreaProps(props) {
    this._touchableAreaProps = this.getTouchableAreaProps(props);
  },

  getTouchableAreaProps: function getTouchableAreaProps(props) {
    return props.disableScroll ? {
      untouchable: true
    } : Object.assign({
      ignoreY: true,
      scroller: this.scroller
    }, props.touchableAreaProps, (props.touchStartBoundsX || props.touchStartBoundsY) && {
      touchStartBoundsX: props.touchStartBoundsX,
      touchStartBoundsY: this.getTouchStartBoundsY()
    }, {
      untouchable: props.touchableAreaProps && props.touchableAreaProps.untouchable || props.disableScroll
    });
  },

  getTouchStartBoundsY: function getTouchStartBoundsY() {
    return this.props.touchStartBoundsY || {
      from: this.getTitleBarHeight(),
      to: this.props.height
    };
  },

  getViewList: function getViewList(props) {
    var _this5 = this;

    var activeTitle;
    var titleBarProps = this.getTitleBarProps();

    return React.createElement(
      TouchableArea,
      _extends({}, this._touchableAreaProps, props),
      !this.props.noFakeTitleBar && React.createElement(TitleBar, _extends({}, this.props.titleBarProps, { animations: {} })),
      clone(this.state.children, function (child, i) {
        if (!child) return;

        return Object.assign({
          key: i,
          index: i,
          titleBarProps: titleBarProps,
          inactive: i !== _this5.state.step,
          isInViewList: true,
          animations: _this5.getViewAnimations(child),
          animationSource: 'viewList',
          animationState: {
            index: i
          },
          viewListScrollToStep: _this5.scrollToStep
        }, i === _this5._advancingToIndex && {
          onComponentMounted: _this5.handleViewMounted
        }, _this5.props.viewProps, _this5.getViewProps && _this5.getViewProps());
      }, true)
    );
  }
});
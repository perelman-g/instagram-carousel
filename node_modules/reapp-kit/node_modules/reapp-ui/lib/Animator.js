'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _defineProperty = function (obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: key == null || typeof Symbol == 'undefined' || key.constructor !== Symbol, configurable: true, writable: true }); };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _React = require('react');

var _React2 = _interopRequireWildcard(_React);

var _Observable = require('observable-state');

var _Observable2 = _interopRequireWildcard(_Observable);

var defined = function defined(attr) {
  return typeof attr !== 'undefined';
};

exports['default'] = function (name, props) {
  return {
    childContextTypes: {
      animations: _React2['default'].PropTypes.object
    },

    getChildContext: function getChildContext() {
      var _this = this;

      var hasStep = this.state && defined(this.state.step);

      // optimization, just return context during animations
      if (hasStep && this.state.step % 1 !== 0) {
        return this.context;
      } // pass through parent animations
      var parentState = undefined;
      if (this.context.animations && this.context.animations[name]) parentState = this.context.animations[name];

      // clone parent to child
      var childState = Object.assign({}, parentState);

      if (hasStep) {
        this.stepper = this.stepper || _Observable2['default'](this.state.step);

        childState.stepper = this.stepper;
      }

      if (props) props.forEach(function (prop) {
        return childState[prop] = _this.props[prop];
      });

      // overwrite animations context for this namespace
      return {
        animations: Object.assign({}, this.context.animations, _defineProperty({}, name, childState))
      };
    } };
};

;
module.exports = exports['default'];